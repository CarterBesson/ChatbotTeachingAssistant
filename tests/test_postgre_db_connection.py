#Tests Generated by ChatGPT
import unittest
from unittest.mock import patch, MagicMock
import os

# Import the get_db_connection function from your module
from backend.database.postgres import get_db_connection

class TestGetDbConnection(unittest.TestCase):

    @patch('backend.database.postgre_db_connection.psycopg2.connect')
    @patch('backend.database.postgre_db_connection.load_dotenv')
    def test_get_db_connection_success(self, mock_load_dotenv, mock_connect):
        # Mock environment variables
        with patch.dict(os.environ, {
            'DB_NAME': 'test_db',
            'DB_USER': 'test_user',
            'DB_PASSWORD': 'test_password',
            'DB_HOST': 'localhost',
            'DB_PORT': '5432'
        }):
            # Mock the psycopg2 connection
            mock_conn = MagicMock()
            mock_connect.return_value = mock_conn

            # Call the function under test
            conn = get_db_connection()

            # Assertions to verify the function's behavior
            self.assertIsNotNone(conn)
            mock_load_dotenv.assert_called_once()
            mock_connect.assert_called_once_with(
                dbname='test_db',
                user='test_user',
                password='test_password',
                host='localhost',
                port=5432
            )

    @patch('backend.database.postgre_db_connection.psycopg2.connect')
    @patch('backend.database.postgre_db_connection.load_dotenv')
    def test_get_db_connection_exception(self, mock_load_dotenv, mock_connect):
        # Mock environment variables
        with patch.dict(os.environ, {
            'DB_NAME': 'test_db',
            'DB_USER': 'test_user',
            'DB_PASSWORD': 'test_password',
            'DB_HOST': 'localhost',
            'DB_PORT': '5432'
        }):
            # Configure the mock to raise an exception
            mock_connect.side_effect = Exception('Database connection failed')

            # Call the function under test and assert it raises an exception
            with self.assertRaises(Exception) as context:
                get_db_connection()

            self.assertIn('Database connection failed', str(context.exception))
            mock_load_dotenv.assert_called_once()
            mock_connect.assert_called_once()

    @patch('backend.database.postgre_db_connection.psycopg2.connect')
    @patch('backend.database.postgre_db_connection.load_dotenv')
    def test_get_db_connection_missing_env_vars(self, mock_load_dotenv, mock_connect):
        # Clear environment variables
        with patch.dict(os.environ, {}, clear=True):
            # Call the function under test and expect it to raise a KeyError or TypeError
            with self.assertRaises(Exception) as context:
                get_db_connection()

            # Ensure that psycopg2.connect was not called due to missing env vars
            mock_connect.assert_not_called()
            mock_load_dotenv.assert_called_once()

    @patch('backend.database.postgre_db_connection.psycopg2.connect')
    @patch('backend.database.postgre_db_connection.load_dotenv')
    def test_get_db_connection_invalid_port(self, mock_load_dotenv, mock_connect):
        # Mock environment variables with invalid port
        with patch.dict(os.environ, {
            'DB_NAME': 'test_db',
            'DB_USER': 'test_user',
            'DB_PASSWORD': 'test_password',
            'DB_HOST': 'localhost',
            'DB_PORT': 'invalid_port'  # Invalid port
        }):
            # Call the function under test and expect it to raise a ValueError
            with self.assertRaises(ValueError) as context:
                get_db_connection()

            self.assertIn("invalid literal for int()", str(context.exception))
            mock_connect.assert_not_called()
            mock_load_dotenv.assert_called_once()

if __name__ == '__main__':
    unittest.main()