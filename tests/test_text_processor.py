#Test generated by ChatGPT
import unittest
from unittest.mock import patch
import backend.database.text_processor as text_processor

class TestFileProcessing(unittest.TestCase):

    def setUp(self):
        """
        Set up test resources: files, byte content, etc.
        """
        # Example text file content
        self.txt_content = b"Hello, this is a simple text file for testing."
        
        # Mock PDF content as binary data (simulating a small PDF file)
        self.pdf_content = b"%PDF-1.4\n%Test PDF content"

    def test_detect_mime_type_txt(self):
        mime_type = text_processor.detect_mime_type(self.txt_content)
        self.assertEqual(mime_type, "text/plain", "MIME type for text file is incorrect")

    def test_extract_text_from_txt(self):
        extracted_text = text_processor.extract_text_from_txt(self.txt_content)
        expected_text = "Hello, this is a simple text file for testing."
        self.assertEqual(extracted_text.strip(), expected_text, "Text extraction from TXT file failed")

    @patch('backend.database.text_processor.extract_text_from_pdf')
    def test_extract_text_from_pdf(self, mock_extract_text_from_pdf):
        # Mock the extracted text from PDF
        mock_extract_text_from_pdf.return_value = "Mock PDF extracted text"
        
        # Call the function under test
        extracted_text = text_processor.extract_text_from_pdf(self.pdf_content)
        
        # Assertions
        self.assertEqual(extracted_text, "Mock PDF extracted text", "Text extraction from PDF should return mocked data")
        mock_extract_text_from_pdf.assert_called_once()

    def test_chunk_text(self):
        text = "This is a long text that should be split into multiple chunks if needed. " * 10
        chunks = text_processor.chunk_text(text, max_tokens=50)
        self.assertTrue(len(chunks) > 1, "Chunking did not split the text properly")

    @patch('backend.database.text_processor.extract_text_from_pdf')
    def test_process_file_pdf(self, mock_extract_text_from_pdf):
        # Mock the extracted text from PDF
        mock_extract_text_from_pdf.return_value = "Mock PDF extracted text"

        # Update the mime_type_to_extractor mapping to use the mocked function
        text_processor.mime_type_to_extractor['application/pdf'] = mock_extract_text_from_pdf

        # Call the function under test
        chunks = text_processor.process_file(self.pdf_content, "test.pdf")

        # Assertions
        self.assertIsInstance(chunks, list, "Chunks should be a list")
        self.assertGreater(len(chunks), 0, "Text should have been processed into at least one chunk")

    def test_process_file_txt(self):
        chunks = text_processor.process_file(self.txt_content, "test.txt")
        self.assertIsInstance(chunks, list, "Chunks should be a list")
        self.assertGreater(len(chunks), 0, "Text should have been processed into at least one chunk")

    def test_mime_mismatch_warning(self):
        with self.assertLogs(level="WARNING") as log:
            _ = text_processor.process_file(self.txt_content, "test.pdf")  # Using wrong extension to simulate mismatch
            self.assertTrue(any("MIME type mismatch" in message for message in log.output))

    def tearDown(self):
        """
        Clean up resources if needed
        """
        pass

if __name__ == "__main__":
    unittest.main()